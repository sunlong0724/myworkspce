// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "AgentServerService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "Camera.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::hawkeye;
extern std::map<std::string, std::vector<double>>  GetDiskInfo();
extern int getCpuUsage();

class AgentServerServiceHandler : virtual public AgentServerServiceIf {
 public:
  AgentServerServiceHandler() {
    // Your initialization goes here
  }

  void find_cameras(std::map<std::string, std::map<int32_t, std::string> > & _return) {
    // Your implementation goes here
	printf("find_cameras\n");
	CCamera::FindCamera(&_return);
  }

  int32_t exec_program(const std::string& cmdline) {
	  // Your implementation goes here
	  printf("exec_program\n");
#if 1
	  STARTUPINFO si = { sizeof(si) };
	  PROCESS_INFORMATION pi;
	  si.dwFlags = STARTF_USESHOWWINDOW;
	  si.wShowWindow = TRUE;
	  fprintf(stdout, "%s cmd:%s\n", __FUNCTION__, cmdline.c_str());
	  BOOL bRet = ::CreateProcess(NULL, (char*)cmdline.c_str(), NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
	  int error = GetLastError();
	  if (bRet) {
		  ::CloseHandle(pi.hThread);
		  ::CloseHandle(pi.hProcess);
		  printf(" The process id:%d \n", pi.dwProcessId);
		  printf(" The main thread id of the process:%d \n", pi.dwThreadId);
		  return pi.dwProcessId;
	  }
	  else {
		  printf("error code:%d\n", error);
		  return -1;
	  }
#endif	
  }

  int32_t kill_program(const int64_t process_id) {
	  // Your implementation goes here
	  printf("kill_program\n");
	  HANDLE hPrc;
	  if (0 == process_id) return FALSE;

	  hPrc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id);  // Opens handle to the process.
	  if (!TerminateProcess(hPrc, 0))  {
		  CloseHandle(hPrc);
		  return FALSE;
	  }
	  else
		  WaitForSingleObject(hPrc, 300); // At most ,waite 300  millisecond.

	  CloseHandle(hPrc);
	  return TRUE;
  }


  void get_disk_info(std::map<std::string, std::vector<double> > & _return) {
	  // Your implementation goes here
	  printf("get_disk_info\n");
	  _return = GetDiskInfo();
  }

  int32_t get_cpu_usage() {
	  // Your implementation goes here
	  printf("get_cpu_usage\n");
	  return getCpuUsage();
  }

};